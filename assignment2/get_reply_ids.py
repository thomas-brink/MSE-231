"""This code was written by
        Eva Batelaan <batelaan@stanford.edu>
        Thomas Brink <tbrink@stanford.edu>
        Michelle Lahrkamp <ml17270@stanford.edu>
    Assignment 2 Group 3

    Searches through reply tweets collected by download_reply_tweets.py to find
    the tweet id each tweet is replying to.
    Collects reply to tweet ids from Twitter streaming API via tweepy and prints the
    pairs as a dict {id:<reply_tweet_id>, replied_to_tweet_id:<replied_to_tweet_id>}.

    Use:
    python3 get_reply_ids.py > congress_df_YYYY-MM-DD_reply_mappings.txt

    The following flags are required:
        --keyfile: twitter API credentials file
            ex: cred.txt
        --reply_tweets: txt of output generated by download_reply_tweets.py
            ex: congress_df_YYYY-MM-DD_reply_tweets.txt

    Note:
    YYYY-MM-DD should match the YYYY-MM-DD in the name of the reply_tweets file
"""
import argparse
import datetime
import sys
import json
import traceback
from tweepy import Stream, Client, StreamingClient, StreamRule, Paginator


def eprint(*args, **kwargs):
    """Print to stderr"""
    print(*args, file=sys.stderr, **kwargs)


class CustomStreamingClient(StreamingClient):
    """Extracted from tweet_stream.py provided in assignment 1"""
    total_tweets = 0
    sunset_time = datetime.datetime.now()

    def __init__(self, write=print, **kwds):
        super(CustomStreamingClient, self).__init__(**kwds)
        self.write = write

    def on_tweet(self, tweet):
        self.write(tweet.data)

    def on_data(self, raw_data):
        self.write(raw_data)
        self.total_tweets += 1

    def on_error(self, status_code):
        eprint(status_code)


def retrieve_reply_to_tweets(id_lst: list):
    """Takes in a list of tweet ids.
    Retrieves the tweet id to which it was replying if applicable,
    Prints the reply tweed id and the id of the tweet it was replying to as a dict.
    """
    count = 0
    try:
        tweet_info = twitter_client.get_tweets(
            ids=id_lst,
            expansions='author_id',
            tweet_fields=['referenced_tweets'],
            user_fields=['public_metrics', 'verified']
        )
        users = {}
        for userObj in tweet_info.includes['users']:
            user = userObj.data
            users[user['id']] = user
        for tweet in tweet_info.data:
            replied_to = []
            for ref_tweet in tweet.referenced_tweets:
                if ref_tweet.type == 'replied_to':
                    replied_to.append(ref_tweet.id)
            if replied_to:
                count += 1
                print(dict({
                    'id': tweet.id,
                    'replied_to_tweet_ids': replied_to,
                    'user_info': users[str(tweet['author_id'])]
                }))
        eprint(count)
    except Exception:
        traceback.print_exc()
        eprint('smth went wrong')


if __name__ == "__main__":
    # Set up the argument parser
    parser = argparse.ArgumentParser(
        description="Fetch data with Twitter Streaming API"
    )
    parser.add_argument(
        "--keyfile", help="file with user credentials", required=True)
    parser.add_argument(
        "--reply_tweets", help="file with initial tweets", required=True)
    flags = parser.parse_args()

    # Read twitter app credentials and set up authentication
    creds = {}
    for line in open(flags.keyfile, "r"):
        row = line.strip()
        if row:
            key, value = row.split()
            creds[key] = value

    twitterstream = Stream(
        creds["api_key"], creds["api_secret"], creds["token"], creds["token_secret"]
    )

    # Track time and start streaming
    starttime = datetime.datetime.now()
    twitter_streaming_client = CustomStreamingClient(
        write=print, bearer_token=creds["bearer_token"])
    twitter_client = Client(
        bearer_token=creds["bearer_token"], wait_on_rate_limit=True)

    # Clear out old rules
    old_rules = twitter_streaming_client.get_rules()
    if old_rules.data is not None:
        rule_ids = [rule.id for rule in old_rules.data]
        twitter_streaming_client.delete_rules(rule_ids)

    # Start streaming
    eprint("Started running at", starttime)
    id_100_list = []
    for line in open(flags.reply_tweets, "r"):
        og_tweet = json.loads(line)
        id_100_list.append(og_tweet['tweet_info']['id'])
        if len(id_100_list) == 100:
            retrieve_reply_to_tweets(id_100_list)
            id_100_list = []

    if len(id_100_list) != 0:
        retrieve_reply_to_tweets(id_100_list)

    eprint("total run time", datetime.datetime.now() - starttime)
