"""This code was written by
        Eva Batelaan <batelaan@stanford.edu>
        Thomas Brink <tbrink@stanford.edu>
        Michelle Lahrkamp <ml17270@stanford.edu>
    Assignment 2 Group 3

    Parses through collected tweets, replies, and reply mappings to build reply
    trees and reply graphs.

    Use:
    python3 create_reply_tree.py

    The following flags are required:
        --initial_tweets: txt of output generated by download_tweets.py
            ex: congress_df_YYYY-MM-DD_tweets.txt
        --reply_tweets: txt of output generated by download_reply_tweets.py
            ex: congress_df_YYYY-MM-DD_reply_tweets.txt
        --reply_mappings: txt of output generated by get_reply_id.py
            ex: congress_df_YYYY-MM-DD_reply_mappings.txt

    Note:
    YYYY-MM-DD should match the YYYY-MM-DD in the name of the reply_tweets file
"""
import argparse
from array import array
import json
import ast
import sys
import numpy as np
import networkx
import traceback
from treelib import Node, Tree


def eprint(*args, **kwargs):
    """Print to stderr
    """
    print(*args, file=sys.stderr, **kwargs)


def create_tweet_tree(tweet: json, cid_tree_dict: dict):
    """Create a reply tree with the original tweet as the root note.
    """
    tweet_info = tweet['tweet_info']
    cid = tweet_info['conversation_id']
    tweet_id = tweet_info['id']
    if cid == tweet_id: # Only make a tree once we've found the original tweet
        tree = Tree()
        tweet_info['public_metrics']['has_dropped_node'] = 0
        tree.create_node(tweet_id, tweet_id, data=tweet_info['public_metrics'])
        cid_tree_dict[cid] = tree


def create_tweet_graph(tweet: json, cid_graph_dict: dict):
    """Create a user graph with the original tweet's author as the inital node.
    """
    tweet_info = tweet['tweet_info']
    cid = tweet_info['conversation_id']
    tweet_id = tweet_info['id']
    if cid == tweet_id: # Only make a graph once we've found the original tweet
        graph = networkx.DiGraph()
        graph.add_node(tweet_info['author_id'],
                       public_metrics=tweet['user_info']['public_metrics'])
        cid_graph_dict[cid] = graph


def create_tweet_tree_node(tweet: json, cid_tree_dict: dict):
    """Add a node for the tweet to the conversation's tweet tree with the root
       node as the default parent.
    """
    tweet_info = tweet['tweet_info']
    cid = tweet_info['conversation_id']
    if cid not in cid_tree_dict.keys():
        pass # Reply tweet with no matching cid (original tweet not available)
    else:
        tree = cid_tree_dict[cid]
        nid = tweet_info['id']
        if nid not in tree.nodes: # Some tweets have the same id
            try:
                tree.create_node(nid, nid, parent=tree.root)
            except:
                tree[tree.root].data['has_dropped_node'] += 1
                eprint('Tree with cid {} dropped node with nid {}, total dropped: {}'.format(
                        cid, nid, tree[tree.root].data['has_dropped_node']
                        ))


def create_tweet_graph_node(tweet: json, cid_graph_dict: dict, reply_user_mappings: dict):
    """Add a node for the reply tweet author to the conversation's user graph.
    """
    tweet_info = tweet['tweet_info']
    cid = tweet_info['conversation_id']
    if cid not in cid_graph_dict.keys():
        pass # Reply tweet with no matching cid (original tweet not available)
    else:
        graph = cid_graph_dict[cid]
        author_id = tweet_info['author_id']
        if author_id not in graph.nodes:
            graph.add_node(author_id,
                           public_metrics=reply_user_mappings[str(tweet_info['id'])])


def create_tweet_graph_edge(tweet: json, cid_graph_dict: dict):
    """Add edge from the author_id to the id of the user to whom they tweet
       is replying to the conversation's user graph.
    """
    tweet_info = tweet['tweet_info']
    cid = tweet_info['conversation_id']
    if cid not in cid_graph_dict.keys():
        pass # Reply tweet with no matching cid (original tweet not available)
    else:
        graph = cid_graph_dict[cid]
        author_id = tweet_info['author_id']
        in_reply_to = tweet_info['in_reply_to_user_id']
        if (author_id, in_reply_to) not in graph.edges:
            graph.add_edge(author_id, in_reply_to)


def reorder_trees(cid_tree_dict: dict, reply_mappings: dict):
    """Once all nodes have been added, connect the nodes to the correct parent
       using the reply to mappings.
    """
    for cid, tree in cid_tree_dict.items():
        for node in tree.all_nodes():
            if node.is_root():
                continue  # don't drop the root node
            nid = node.identifier
            parent_nid = reply_mappings.get(nid)
            try:
                tree.move_node(nid, parent_nid)
            except:
                nodes_dropped = len(tree.subtree(nid).nodes)
                tree[tree.root].data['has_dropped_node'] += nodes_dropped
                if parent_nid == None:
                    pass # Tweet could have been deleted
                else:
                    pass # Tweet not available to be pulled (not public,
                         # not in scope of 7 days, etc.)
                tree.remove_node(nid)


def create_reply_trees_and_graphs(reply_tweets, initial_tweets, reply_mappings):
    """Parse through the collected data and build the reply trees
       and user graphs.
    """
    # Extract cids for which we got replies.
    reply_cids = set()
    for line in open(reply_tweets, "r"):
        tweet = json.loads(line)
        reply_cids.add(tweet['tweet_info']['conversation_id'])
    
    eprint('Number of reply cids found: {}'.format(len(reply_cids)))

    # Make trees and graphs.
    cid_tree_dict = {}
    cid_graph_dict = {}
    prob_sample = 0.3 
    for line in open(initial_tweets, "r"):
        tweet = json.loads(line)
        cid = tweet['tweet_info']['conversation_id']
        reply_count = tweet['tweet_info']['public_metrics']['reply_count']
        # Only include conversations for which we retrieved replies
        # and randomly select conversations with no replies.
        if cid in reply_cids or (reply_count == 0 and np.random.uniform() < prob_sample):
            create_tweet_tree(tweet, cid_tree_dict)
            create_tweet_graph(tweet, cid_graph_dict)
    
    eprint('Length of cid_tree_dict: {}, length of cid_graph_dict: {}'
           .format(len(cid_tree_dict), len(cid_graph_dict)))

    # Build dictionary of tweet ids to which reply tweets are replying
    reply_to_mappings = {}
    # Build dictionary of user info of reply tweets
    reply_user_mappings = {}
    for line in open(reply_mappings, "r"):
        data = ast.literal_eval(line)
        reply_to_mappings[str(data['id'])] = str(data['replied_to_tweet_ids'])
        reply_user_mappings[str(data['id'])] = str(data['user_info'])
    
    # Add replies that were pulled when pulling original conversations
    for line in open(initial_tweets, "r"):
        tweet = json.loads(line)
        tweet_info = tweet['tweet_info']
        if tweet_info['id'] != tweet_info['conversation_id']:
            create_tweet_tree_node(tweet, cid_tree_dict)
            create_tweet_graph_node(tweet, cid_graph_dict, reply_user_mappings)

    # Add reply tweets to reply trees and user graphs
    for line in open(reply_tweets, "r"):
        tweet = json.loads(line)
        create_tweet_tree_node(tweet, cid_tree_dict)
        create_tweet_graph_node(tweet, cid_graph_dict, reply_user_mappings)

    # Reassign parents in reply tweets using reply mappings
    reorder_trees(cid_tree_dict, reply_mappings)

    # Add edges to user graph
    for line in open(reply_tweets, "r"):
        tweet = json.loads(line)
        create_tweet_graph_edge(tweet, cid_graph_dict)

    return cid_tree_dict, cid_graph_dict


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Fetch data with Twitter Streaming API"
    )
    parser.add_argument(
        "--initial_tweets", help="file with initial tweets", required=True)
    parser.add_argument(
        "--reply_tweets", help="file with reply tweets", required=True)
    parser.add_argument(
        "--reply_mappings", help="file with reply tweets mappings", required=True)
    flags = parser.parse_args()
    print(flags)

    cid_tree_dict, cid_graph_dict = create_reply_trees_and_graphs(
        flags.reply_tweets, flags.initial_tweets, flags.reply_mappings
    )

    # print('1587162493889044480')
    # tree = cid_tree_dict['1587162493889044480']
    # print(tree.show())
    # graph = cid_graph_dict['1587162493889044480']
    # print('nodes: ', graph.nodes)
    # print('edges: ', graph.edges)

    # for key, value in cid_graph_dict.items():
    #   print(key, value)
